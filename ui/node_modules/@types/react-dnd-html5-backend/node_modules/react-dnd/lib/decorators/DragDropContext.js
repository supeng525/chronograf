import * as React from 'react';
import { DndContext, createDndContext } from '../common/DndContext';
import { checkDecoratorArguments, isRefable } from './utils';
// @ts-ignore
import invariant from 'invariant';
// @ts-ignore
import hoistStatics from 'hoist-non-react-statics';
/**
 * Wrap the root component of your application with DragDropContext decorator to set up React DnD.
 * This lets you specify the backend, and sets up the shared DnD state behind the scenes.
 * @param backendFactory The DnD backend factory
 * @param backendContext The backend context
 */
export function DragDropContext(backendFactory, backendContext, debugMode) {
    checkDecoratorArguments('DragDropContext', 'backend', backendFactory);
    const childContext = createDndContext(backendFactory, backendContext, debugMode);
    return function decorateContext(DecoratedComponent) {
        const Decorated = DecoratedComponent;
        const displayName = Decorated.displayName || Decorated.name || 'Component';
        class DragDropContextContainer extends React.Component {
            constructor() {
                super(...arguments);
                this.ref = React.createRef();
                this.getManager = () => childContext.dragDropManager;
            }
            getDecoratedComponentInstance() {
                invariant(this.ref.current, 'In order to access an instance of the decorated component, it must either be a class component or use React.forwardRef()');
                return this.ref.current;
            }
            render() {
                return (React.createElement(DndContext.Provider, { value: childContext },
                    React.createElement(Decorated, Object.assign({}, this.props, { ref: isRefable(Decorated) ? this.ref : null }))));
            }
        }
        DragDropContextContainer.DecoratedComponent = DecoratedComponent;
        DragDropContextContainer.displayName = `DragDropContext(${displayName})`;
        return hoistStatics(DragDropContextContainer, DecoratedComponent);
    };
}
